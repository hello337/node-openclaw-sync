#!/usr/bin/env bash
#
# OpenClaw <-> xNode sync: fetches config from xNode API and applies it to the local
# OpenClaw instance (agents_defaults, tools_web_search, oauth_url_requests, oauth_pending).
#
# Flow:
# - API keys (env): sent in config, applied via config.patch so OpenClaw gets env and models.
# - OAuth "request link": user clicks "Get auth link" -> we enable plugin if needed, run
#   openclaw models auth login --provider X, capture URL, POST to xNode -> frontend shows link.
# - OAuth "apply": user pastes callback URL or token -> we run login/paste-token with that
#   value, then POST oauth-consumed. agents_defaults from API enables all models for that provider.
#
# Required env: OPENCLAW_CONFIG_TOKEN. Optional: OPENCLAW_API_BASE (default https://api.xnode.pro)
# API: GET /openclaw/config, POST /openclaw/oauth-auth-url, POST /openclaw/oauth-consumed
#
# OpenClaw docs (verified):
# - config.get / config.patch: docs.openclaw.ai/gateway/configuration
# - agents.defaults: docs.openclaw.ai/gateway/configuration-examples
# - tools.web.search: docs.openclaw.ai/gateway/configuration-reference
# - Plugins & auth: docs.openclaw.ai/concepts/model-providers, concepts/oauth
# - CLI models auth login: docs.openclaw.ai/cli/models
#     IMPORTANT: requires interactive TTY to print device-code URL (GitHub #13192).
#     We use `script -qec` to provide a pseudo-TTY from systemd.
# - gateway start/stop: docs.openclaw.ai/cli/gateway — needs XDG_RUNTIME_DIR for user services.
# - plugins enable/list: docs.openclaw.ai/cli/plugins — enable is idempotent; restart gateway to load.
# - gateway health: docs.openclaw.ai/gateway/health — `openclaw gateway health` or `openclaw health`.
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/env" ]; then
    set -a
    # shellcheck source=/dev/null
    source "$SCRIPT_DIR/env"
    set +a
fi

: "${OPENCLAW_CONFIG_TOKEN:?Set OPENCLAW_CONFIG_TOKEN (from xNode admin: OpenClaw node -> Token)}"
: "${OPENCLAW_API_BASE:=https://api.xnode.pro}"
OPENCLAW_API_BASE="${OPENCLAW_API_BASE%/}"
[ -z "$OPENCLAW_API_BASE" ] && OPENCLAW_API_BASE="https://api.xnode.pro"

export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

if ! command -v jq &>/dev/null; then
    echo "jq is required." >&2
    exit 1
fi

# ──────────────────────────────────────────────────────────────────────────────
# Helpers
# ──────────────────────────────────────────────────────────────────────────────

plugin_for_key() {
    case "$1" in
        google_antigravity) echo "google-antigravity-auth" ;;
        qwen_portal)        echo "qwen-portal-auth" ;;
        google_gemini_cli)  echo "google-gemini-cli-auth" ;;
        minimax_portal)     echo "minimax-portal-auth" ;;
        *)                  echo "" ;;
    esac
}

provider_for_key() {
    echo "$1" | sed 's/_/-/g'
}

strip_ansi() {
    sed $'s/\x1b\[[0-9;]*[a-zA-Z]//g; s/\x1b([0-9;]*[a-zA-Z]//g; s/\r//g'
}

# Detect pseudo-TTY support (Linux `script -qec`)
HAS_SCRIPT_PTY=0
if command -v script &>/dev/null; then
    if script -q -e -c "echo __pty_ok__" /dev/null 2>/dev/null | grep -q "__pty_ok__"; then
        HAS_SCRIPT_PTY=1
    fi
fi

# Run a command with a timeout. If we have `script`, wrap in a pseudo-TTY so
# interactive CLIs (like openclaw models auth login) produce full output.
run_with_pty() {
    local t="$1"; shift
    if [ "$HAS_SCRIPT_PTY" = "1" ]; then
        local cmd
        cmd="$(printf '%q ' "$@")"
        timeout "$t" script -q -e -c "$cmd" /dev/null 2>&1 | strip_ansi
    elif command -v timeout &>/dev/null; then
        timeout "$t" "$@" 2>&1
    else
        "$@" 2>&1
    fi
}

# Plain timeout wrapper (no PTY needed)
run_with_timeout() {
    local t="$1"; shift
    if command -v timeout &>/dev/null; then
        timeout "$t" "$@" 2>&1
    else
        "$@" 2>&1
    fi
}

# ──────────────────────────────────────────────────────────────────────────────
# 0) Fetch config from xNode
# ──────────────────────────────────────────────────────────────────────────────

RESP="$(curl -s -S -w "\n%{http_code}" -H "Authorization: Bearer $OPENCLAW_CONFIG_TOKEN" "$OPENCLAW_API_BASE/openclaw/config")"
HTTP_CODE="$(echo "$RESP" | tail -1)"
RESP_BODY="$(echo "$RESP" | sed '$d')"

if [ "$HTTP_CODE" != "200" ]; then
    echo "Failed to fetch config: HTTP $HTTP_CODE" >&2
    exit 1
fi

if [ -z "$RESP_BODY" ] || ! echo "$RESP_BODY" | head -c1 | grep -q '{'; then
    echo "Failed to fetch config: invalid or empty response" >&2
    exit 1
fi

if ! echo "$RESP_BODY" | jq -e . >/dev/null 2>&1; then
    echo "Failed to fetch config: response is not valid JSON" >&2
    exit 1
fi

RESP="$RESP_BODY"

# Ensure gateway allows local CLI connections without manual pairing.
# File-level change; takes effect on next gateway restart.
if command -v openclaw &>/dev/null; then
    openclaw config set gateway.controlUi.allowInsecureAuth true 2>/dev/null || true
fi

# ──────────────────────────────────────────────────────────────────────────────
# 1) Apply agents_defaults and tools_web_search via config.patch
# ──────────────────────────────────────────────────────────────────────────────

AGENTS_DEFAULTS="$(echo "$RESP" | jq -c '.agents_defaults // empty' 2>/dev/null)" || AGENTS_DEFAULTS=""
TOOLS_WEB_SEARCH="$(echo "$RESP" | jq -c '.tools_web_search // empty' 2>/dev/null)" || TOOLS_WEB_SEARCH=""
NEED_PATCH="false"

if [ -n "$AGENTS_DEFAULTS" ] && [ "$AGENTS_DEFAULTS" != "null" ] && \
   [ "$(echo "$AGENTS_DEFAULTS" | jq -r 'keys | length' 2>/dev/null)" -gt 0 ] 2>/dev/null; then
    NEED_PATCH="true"
fi
if [ -n "$TOOLS_WEB_SEARCH" ] && [ "$TOOLS_WEB_SEARCH" != "null" ]; then
    NEED_PATCH="true"
fi

if [ "$NEED_PATCH" = "true" ] && command -v openclaw &>/dev/null; then
    HASH="$(openclaw gateway call config.get --params '{}' 2>/dev/null | jq -r '.payload.hash // .hash // empty' 2>/dev/null)" || HASH=""
    if [ -n "$HASH" ]; then
        RAW_JSON="$(jq -n \
            --argjson ad "${AGENTS_DEFAULTS:-null}" \
            --argjson tw "${TOOLS_WEB_SEARCH:-null}" \
            '(if $ad != null and ($ad | type) == "object" and ($ad | keys | length) > 0
              then { agents: { defaults: $ad } } else {} end)
           * (if $tw != null and ($tw | type) == "object" and ($tw | keys | length) > 0
              then { tools: { web: { search: $tw } } } else {} end)' \
            2>/dev/null | jq -c . 2>/dev/null)" || RAW_JSON=""
        if [ -n "$RAW_JSON" ] && [ "$RAW_JSON" != "{}" ]; then
            PARAMS="$(jq -n --arg h "$HASH" --arg r "$RAW_JSON" '{ baseHash: $h, raw: $r }' 2>/dev/null)" || true
            if [ -n "$PARAMS" ] && ! openclaw gateway call config.patch --params "$PARAMS" 2>/dev/null; then
                echo "Warning: config.patch failed (gateway may be down or unreachable)" >&2
            fi
        fi
    fi
fi

# ──────────────────────────────────────────────────────────────────────────────
# 2) oauth_url_requests: enable plugin → restart gateway → get auth URL → POST
# ──────────────────────────────────────────────────────────────────────────────

OAUTH_URL_REQUESTS_RAW="$(echo "$RESP" | jq -r '.oauth_url_requests // {} | to_entries[] | select(.value == true) | .key' 2>/dev/null)" || true
[ -z "$OAUTH_URL_REQUESTS_RAW" ] && OAUTH_URL_REQUESTS_RAW=""

# -- Phase A: enable plugins that aren't yet enabled --
NEED_GATEWAY_RESTART=0
RESTART_FLAG="/tmp/openclaw-sync-gateway-restarted"

while IFS= read -r KEY || [ -n "$KEY" ]; do
    KEY="$(echo "${KEY:-}" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$KEY" ] && continue
    command -v openclaw &>/dev/null || continue

    PLUGIN="$(plugin_for_key "$KEY")"
    [ -z "$PLUGIN" ] && continue

    # Check if plugin is already known to the CLI (enabled in config).
    # `plugins list` reads from config + discovery, so it works even if
    # the gateway hasn't loaded the plugin yet.
    if openclaw plugins list 2>/dev/null | grep -qi "$PLUGIN"; then
        continue
    fi

    ENABLE_OUT="$(openclaw plugins enable "$PLUGIN" 2>&1)" || true
    echo "plugins enable $PLUGIN: $ENABLE_OUT" >&2
    NEED_GATEWAY_RESTART=1
done <<< "$OAUTH_URL_REQUESTS_RAW"

# -- Gateway restart with loop prevention --
# Only restart if we just enabled a NEW plugin. A flag file with 120s cooldown
# prevents the script from re-restarting on every run. After restart we exit 0
# to let the gateway fully start before Phase B runs on the next timer tick.
if [ "$NEED_GATEWAY_RESTART" = "1" ]; then
    SKIP_RESTART=0
    if [ -f "$RESTART_FLAG" ]; then
        FLAG_MTIME="$(stat -c %Y "$RESTART_FLAG" 2>/dev/null || stat -f %m "$RESTART_FLAG" 2>/dev/null || echo 0)"
        NOW="$(date +%s)"
        FLAG_AGE=$(( NOW - FLAG_MTIME ))
        if [ "$FLAG_AGE" -lt 120 ]; then
            SKIP_RESTART=1
        fi
    fi

    if [ "$SKIP_RESTART" = "0" ]; then
        echo "Restarting OpenClaw gateway to load new plugin(s)..." >&2
        openclaw gateway stop 2>&1 || true
        GATEWAY_PORT="${OPENCLAW_GATEWAY_PORT:-18789}"
        for i in 1 2 3 4 5 6 7 8 9 10; do
            if ! (lsof -nP -iTCP:"$GATEWAY_PORT" -sTCP:LISTEN 2>/dev/null | grep -q .); then
                break
            fi
            [ "$i" -eq 1 ] && echo "Waiting for gateway port $GATEWAY_PORT to be free..." >&2
            sleep 1
        done
        # Non-zero exit from `gateway start` may just mean the health check
        # timed out (OpenClaw #22972); the daemon is still starting.
        openclaw gateway start 2>&1 || true
        touch "$RESTART_FLAG"
        echo "Gateway restart initiated. Auth URL will be fetched on next run (~10s)." >&2
        exit 0
    fi
fi

# -- Pre-flight: check that the gateway is reachable before Phase B --
if [ -n "$OAUTH_URL_REQUESTS_RAW" ]; then
    if ! openclaw gateway health --timeout 10000 2>/dev/null; then
        echo "Gateway is not healthy; skipping auth URL fetch. Will retry next run." >&2
        exit 0
    fi
fi

# -- Phase B: run auth login and capture the device-code URL --
# OpenClaw's auth login opens the URL in a browser (via xdg-open / the `open` npm
# package). On a headless server there's no browser, so the URL is lost.
# We intercept it two ways:
#   1) BROWSER env var — xdg-open and some Node helpers check this first.
#   2) Fake xdg-open early in PATH — catches direct xdg-open calls.
# Both write the URL to a temp file so we can read it after the command exits.
FAKE_BIN_DIR="/tmp/openclaw-sync-fakebin-$$"
mkdir -p "$FAKE_BIN_DIR"

cat > "$FAKE_BIN_DIR/url-capture" << 'CAPTURE_EOF'
#!/bin/sh
echo "$1" >> "$OPENCLAW_URL_CAPTURE_FILE"
CAPTURE_EOF
chmod +x "$FAKE_BIN_DIR/url-capture"

cat > "$FAKE_BIN_DIR/xdg-open" << 'XDG_EOF'
#!/bin/sh
echo "$1" >> "$OPENCLAW_URL_CAPTURE_FILE"
XDG_EOF
chmod +x "$FAKE_BIN_DIR/xdg-open"

ORIG_PATH="$PATH"

while IFS= read -r KEY || [ -n "$KEY" ]; do
    KEY="$(echo "${KEY:-}" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$KEY" ] && continue
    command -v openclaw &>/dev/null || { echo "oauth_url_requests.$KEY: openclaw not in PATH" >&2; continue; }

    PROVIDER="$(provider_for_key "$KEY")"
    URL_CAPTURE_FILE="/tmp/openclaw-sync-url-$$-$KEY"
    rm -f "$URL_CAPTURE_FILE"

    export BROWSER="$FAKE_BIN_DIR/url-capture"
    export OPENCLAW_URL_CAPTURE_FILE="$URL_CAPTURE_FILE"
    export PATH="$FAKE_BIN_DIR:$ORIG_PATH"

    OUT="$(run_with_pty 45 openclaw models auth login --provider "$PROVIDER")" || true

    export PATH="$ORIG_PATH"
    unset BROWSER OPENCLAW_URL_CAPTURE_FILE

    # Primary: read URL from the capture file (written by our fake browser)
    AUTH_URL=""
    if [ -f "$URL_CAPTURE_FILE" ]; then
        AUTH_URL="$(head -1 "$URL_CAPTURE_FILE" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
        echo "oauth_url_requests.$KEY: captured URL via BROWSER intercept: $AUTH_URL" >&2
    fi

    # Fallback: try to extract from stdout (some providers print the URL directly)
    if [ -z "$AUTH_URL" ] && [ -n "$OUT" ]; then
        AUTH_URL="$(echo "$OUT" | grep -oE 'https://[^ )[\]"'\''<>]+' | head -1)"
        [ -z "$AUTH_URL" ] && AUTH_URL="$(echo "$OUT" | grep -oE 'https?://[^ )[\]"'\''<>]+' | head -1)"
        [ -n "$AUTH_URL" ] && echo "oauth_url_requests.$KEY: extracted URL from stdout: $AUTH_URL" >&2
    fi

    rm -f "$URL_CAPTURE_FILE"

    if echo "$OUT" | grep -qi "no provider plugins found\|provider not found\|unknown provider"; then
        echo "oauth_url_requests.$KEY: plugin not loaded. Restart the gateway: openclaw gateway restart" >&2
        continue
    fi

    if [ -z "$AUTH_URL" ]; then
        echo "oauth_url_requests.$KEY: no URL captured. Try running manually: openclaw models auth login --provider $PROVIDER" >&2
        continue
    fi

    # POST auth URL to xNode
    POST_BODY="$(jq -n --arg k "$KEY" --arg u "$AUTH_URL" '{ key: $k, auth_url: $u }' 2>/dev/null)" || true
    if [ -z "$POST_BODY" ]; then
        echo "oauth_url_requests.$KEY: failed to build request body" >&2
        continue
    fi

    POST_RESP="$(curl -s -w "\n%{http_code}" -X POST \
        -H "Authorization: Bearer $OPENCLAW_CONFIG_TOKEN" \
        -H "Content-Type: application/json" \
        -d "$POST_BODY" \
        "$OPENCLAW_API_BASE/openclaw/oauth-auth-url")" || true
    POST_CODE="$(echo "$POST_RESP" | tail -1)"

    if [ "$POST_CODE" = "200" ] && echo "$POST_RESP" | sed '$d' | jq -e '.ok' >/dev/null 2>&1; then
        echo "oauth_url_requests.$KEY: auth URL sent to xNode" >&2
        rm -f "$RESTART_FLAG"
    else
        echo "oauth_url_requests.$KEY: POST failed (HTTP $POST_CODE). Check OPENCLAW_API_BASE=$OPENCLAW_API_BASE" >&2
    fi
done <<< "$OAUTH_URL_REQUESTS_RAW"

rm -rf "$FAKE_BIN_DIR"

# ──────────────────────────────────────────────────────────────────────────────
# 3) oauth_pending: apply tokens/URLs, then mark consumed
# ──────────────────────────────────────────────────────────────────────────────

apply_oauth_pending() {
    local key="$1"
    local val="$2"
    [ -z "$val" ] && return 1
    [ "$val" = "null" ] && return 1
    if [ "$key" = "anthropic_setup_token" ]; then
        echo "$val" | openclaw models auth paste-token --provider anthropic 2>/dev/null
    else
        local provider
        provider="$(echo "$key" | sed 's/_/-/g')"
        (echo "$val"; sleep 1) | run_with_timeout 45 openclaw models auth login --provider "$provider" 2>/dev/null
    fi
}

OAUTH_PENDING_KEYS="$(echo "$RESP" | jq -r '.oauth_pending // {} | keys[]' 2>/dev/null)" || true
if [ -z "$OAUTH_PENDING_KEYS" ]; then
    exit 0
fi

CONSUMED=()
while IFS= read -r KEY || [ -n "$KEY" ]; do
    KEY="$(echo "${KEY:-}" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$KEY" ] && continue
    VAL="$(echo "$RESP" | jq -r --arg k "$KEY" '.oauth_pending[$k] // empty' 2>/dev/null)" || VAL=""
    [ -z "$VAL" ] && continue
    [ "$VAL" = "null" ] && continue
    if apply_oauth_pending "$KEY" "$VAL"; then
        CONSUMED+=("$KEY")
    fi
done <<< "$OAUTH_PENDING_KEYS"

if [ ${#CONSUMED[@]} -eq 0 ]; then
    exit 0
fi

KEYS_JSON="$(printf '%s\n' "${CONSUMED[@]}" | jq -R . | jq -s . 2>/dev/null)" || exit 1
CONSUMED_RESP="$(curl -s -w "\n%{http_code}" -X POST \
    -H "Authorization: Bearer $OPENCLAW_CONFIG_TOKEN" \
    -H "Content-Type: application/json" \
    -d "{\"keys\": $KEYS_JSON}" \
    "$OPENCLAW_API_BASE/openclaw/oauth-consumed")" || true
CONSUMED_CODE="$(echo "$CONSUMED_RESP" | tail -1)"
if [ "$CONSUMED_CODE" != "200" ]; then
    echo "Warning: POST oauth-consumed returned HTTP $CONSUMED_CODE (keys may be retried on next run)" >&2
fi
