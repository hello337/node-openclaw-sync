#!/usr/bin/env bash
#
# OpenClaw <-> xNode sync: fetches config from xNode API and applies it to the local
# OpenClaw instance (agents_defaults, tools_web_search, oauth_url_requests, oauth_pending).
#
# Supported auth flows (per provider):
#   device-code (direct API — no CLI needed, fully reliable):
#     - qwen_portal:    chat.qwen.ai PKCE device-code
#     - github_copilot: github.com device flow (RFC 8628)
#     - minimax_portal: api.minimax.io device-code with PKCE
#   redirect OAuth (direct API — PKCE verifier persisted between runs):
#     - openai_codex:        auth.openai.com PKCE redirect, client_id: app_EMoamEEZ73f0CkXaXp7hrann
#     - google_gemini_cli:   accounts.google.com PKCE redirect, client_id extracted from Gemini CLI
#   paste-token:
#     - anthropic_setup_token: openclaw models auth paste-token
#
# Required env: OPENCLAW_CONFIG_TOKEN
# Optional: OPENCLAW_API_BASE (default https://api.xnode.pro)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/env" ]; then
    set -a; source "$SCRIPT_DIR/env"; set +a
fi

: "${OPENCLAW_CONFIG_TOKEN:?Set OPENCLAW_CONFIG_TOKEN (from xNode admin: OpenClaw node -> Token)}"
: "${OPENCLAW_API_BASE:=https://api.xnode.pro}"
OPENCLAW_API_BASE="${OPENCLAW_API_BASE%/}"
[ -z "$OPENCLAW_API_BASE" ] && OPENCLAW_API_BASE="https://api.xnode.pro"

export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/$(id -u)}"

# systemd services often have empty HOME — resolve from /etc/passwd
if [ -z "$HOME" ]; then
    HOME="$(getent passwd "$(whoami)" 2>/dev/null | cut -d: -f6)" || HOME="/root"
    export HOME
fi

OPENCLAW_STATE_DIR="${OPENCLAW_STATE_DIR:-$HOME/.openclaw}"
DEVICE_CODE_STATE_DIR="/tmp/openclaw-sync-device-codes"
RESTART_FLAG="/tmp/openclaw-sync-gateway-restarted"
PROFILES_FILE="$OPENCLAW_STATE_DIR/agents/main/agent/auth-profiles.json"

# Track whether a full gateway restart is needed (auth-profiles.json changed)
OAUTH_TOKEN_SAVED=0

echo "env: HOME=$HOME OPENCLAW_STATE_DIR=$OPENCLAW_STATE_DIR PROFILES_FILE=$PROFILES_FILE" >&2

if ! command -v jq &>/dev/null; then echo "jq is required." >&2; exit 1; fi
if ! command -v openssl &>/dev/null; then echo "openssl is required." >&2; exit 1; fi

# Auto-install @google/gemini-cli for Gemini OAuth credentials extraction
if ! command -v gemini &>/dev/null && command -v npm &>/dev/null; then
    echo "gemini-cli not found, installing @google/gemini-cli..." >&2
    npm install -g @google/gemini-cli 2>&1 | tail -1 >&2 || echo "gemini-cli install failed (non-fatal)" >&2
fi

# ──────────────────────────────────────────────────────────────────────────────
# Helpers
# ──────────────────────────────────────────────────────────────────────────────

plugin_for_key() {
    case "$1" in
        qwen_portal)        echo "qwen-portal-auth" ;;
        google_gemini_cli)  echo "google-gemini-cli-auth" ;;
        minimax_portal)     echo "minimax-portal-auth" ;;
        *) echo "" ;;
    esac
}

provider_for_key() { echo "$1" | sed 's/_/-/g'; }

strip_ansi() {
    sed $'s/\x1b\[[0-9;?]*[a-zA-Z]//g; s/\x1b([0-9;]*[a-zA-Z]//g; s/\x1b][^\x07\x1b]*[\x07]//g; s/\r//g'
}

HAS_SCRIPT_PTY=0
if command -v script &>/dev/null; then
    if script -q -e -c "echo __pty_ok__" /dev/null 2>/dev/null | grep -q "__pty_ok__"; then
        HAS_SCRIPT_PTY=1
    fi
fi

run_with_timeout() {
    local t="$1"; shift
    if command -v timeout &>/dev/null; then timeout "$t" "$@" 2>&1
    else "$@" 2>&1; fi
}

# Call gateway RPC and return clean JSON. Strips ANSI banner, retries on failure.
gateway_call_json() {
    local _attempt
    for _attempt in 1 2 3; do
        local _raw _json
        _raw="$(openclaw gateway call "$@" 2>/dev/null)" || { sleep 2; continue; }
        [ -z "$_raw" ] && { sleep 2; continue; }
        _json="$(echo "$_raw" | strip_ansi | sed -n '/^[[:space:]]*[{[]/,$p')"
        if [ -n "$_json" ] && echo "$_json" | jq -e '.' &>/dev/null; then
            echo "$_json"
            return 0
        fi
        sleep 2
    done
    return 1
}

generate_pkce() {
    local verifier challenge
    verifier="$(openssl rand -base64 32 | tr '+/' '-_' | tr -d '=')"
    challenge="$(printf '%s' "$verifier" | openssl dgst -sha256 -binary | openssl base64 | tr '+/' '-_' | tr -d '=')"
    echo "$verifier $challenge"
}

save_state() {
    local key="$1"; shift
    mkdir -p "$DEVICE_CODE_STATE_DIR"
    jq -n "$@" > "$DEVICE_CODE_STATE_DIR/$key.json"
}

save_pending_config() {
    local provider="$1" config_json="$2"
    mkdir -p "$DEVICE_CODE_STATE_DIR"
    printf '%s' "$config_json" > "$DEVICE_CODE_STATE_DIR/${provider}_config_pending.json"
}

retry_pending_configs() {
    [ -d "$DEVICE_CODE_STATE_DIR" ] || return 0
    for pf in "$DEVICE_CODE_STATE_DIR"/*_config_pending.json; do
        [ -f "$pf" ] || continue
        local pk cfg
        pk="$(basename "$pf" _config_pending.json)"
        cfg="$(cat "$pf" 2>/dev/null)" || { rm -f "$pf"; continue; }
        [ -z "$cfg" ] && { rm -f "$pf"; continue; }
        if apply_provider_config_patch "$cfg"; then
            echo "retry_config.$pk: config.patch applied" >&2
            rm -f "$pf"
        else
            echo "retry_config.$pk: config.patch still failing, will retry" >&2
        fi
    done
}

save_auth_profile() {
    local profile_id="$1" profile_json="$2"
    local dir
    dir="$(dirname "$PROFILES_FILE")"
    if ! mkdir -p "$dir" 2>/dev/null; then
        echo "save_auth_profile: FAILED to create dir $dir" >&2; return 1
    fi
    local existing='{"version":1,"profiles":{}}'
    if [ -f "$PROFILES_FILE" ]; then
        existing="$(jq -c '.' "$PROFILES_FILE" 2>/dev/null)" || existing='{"version":1,"profiles":{}}'
        if ! echo "$existing" | jq -e '.version' &>/dev/null; then
            existing="$(echo "$existing" | jq -c '{ version: 1, profiles: . }')"
        fi
        if ! echo "$existing" | jq -e '.profiles' &>/dev/null; then
            existing="$(echo "$existing" | jq -c '. + { profiles: {} }')"
        fi
    fi
    local updated
    updated="$(echo "$existing" | jq --arg pid "$profile_id" --argjson prof "$profile_json" \
        '.profiles[$pid] = $prof')" || { echo "save_auth_profile: jq merge failed for $profile_id" >&2; return 1; }
    if [ -z "$updated" ]; then
        echo "save_auth_profile: jq produced empty output for $profile_id" >&2; return 1
    fi
    echo "$updated" > "$PROFILES_FILE" || { echo "save_auth_profile: FAILED to write $PROFILES_FILE" >&2; return 1; }
    chmod 600 "$PROFILES_FILE" 2>/dev/null || true
    if [ -f "$PROFILES_FILE" ]; then
        echo "save_auth_profile: OK — wrote $PROFILES_FILE ($(wc -c < "$PROFILES_FILE") bytes)" >&2
    else
        echo "save_auth_profile: CRITICAL — file not found after write: $PROFILES_FILE" >&2
        return 1
    fi
}

apply_provider_config_patch() {
    local provider_config_json="$1"
    command -v openclaw &>/dev/null || { echo "apply_provider_config_patch: openclaw not found, skipping" >&2; return 0; }

    local GET_RESP HASH
    GET_RESP="$(gateway_call_json config.get --params '{}')" || {
        echo "apply_provider_config_patch: config.get command failed" >&2; return 1
    }
    if [ -z "$GET_RESP" ]; then
        echo "apply_provider_config_patch: config.get returned empty response" >&2; return 1
    fi

    HASH="$(echo "$GET_RESP" | jq -r '.hash // empty' 2>/dev/null)" || HASH=""
    if [ -z "$HASH" ]; then
        local resp_keys
        resp_keys="$(echo "$GET_RESP" | jq -r 'keys | join(", ")' 2>/dev/null)" || resp_keys="(not valid json)"
        echo "apply_provider_config_patch: could not extract baseHash (keys: $resp_keys)" >&2
        return 1
    fi

    local PARAMS PATCH_RESP
    PARAMS="$(jq -n --arg h "$HASH" --arg r "$provider_config_json" '{ baseHash: $h, raw: $r }' 2>/dev/null)" || return 1
    PATCH_RESP="$(gateway_call_json config.patch --params "$PARAMS")" || {
        echo "apply_provider_config_patch: config.patch command failed" >&2; return 1
    }
    local ok_field err_msg
    ok_field="$(echo "$PATCH_RESP" | jq -r '.ok // empty' 2>/dev/null)"
    err_msg="$(echo "$PATCH_RESP" | jq -r 'if .error then (if .error | type == "string" then .error elif .error | type == "object" then (.error.message // (.error | tostring)) else (.error | tostring) end) else empty end' 2>/dev/null)"
    if [ -n "$err_msg" ]; then
        echo "apply_provider_config_patch: config.patch error: $err_msg" >&2; return 1
    fi
    if [ "$ok_field" = "false" ]; then
        echo "apply_provider_config_patch: config.patch ok=false: $(echo "$PATCH_RESP" | jq -c '.' 2>/dev/null | head -c 500)" >&2; return 1
    fi
    return 0
}

post_oauth_consumed() {
    local key="$1"
    local resp code
    resp="$(curl -s -w "\n%{http_code}" -X POST \
        -H "Authorization: Bearer $OPENCLAW_CONFIG_TOKEN" \
        -H "Content-Type: application/json" \
        -d "{\"keys\": [\"$key\"]}" \
        "$OPENCLAW_API_BASE/openclaw/oauth-consumed" 2>/dev/null)" || true
    code="$(echo "$resp" | tail -1)"
    if [ "$code" != "200" ]; then
        echo "post_oauth_consumed($key): HTTP $code" >&2
    fi
}

url_decode() {
    printf '%b' "$(echo "$1" | sed 's/+/ /g; s/%\([0-9a-fA-F][0-9a-fA-F]\)/\\x\1/g')"
}

extract_url_param() {
    local url="$1" param="$2"
    local val
    val="$(echo "$url" | grep -oE "[?&]${param}=([^&]*)" | head -1 | sed "s/[?&]${param}=//")"
    [ -n "$val" ] && url_decode "$val"
}

# Full gateway stop+start to reload auth-profiles.json and config from disk.
# SIGUSR1 (triggered by config.patch) only reloads openclaw.json but NOT
# the AuthProfileStore cache, so OAuth credentials written to auth-profiles.json
# won't be picked up without a full restart.
full_gateway_restart() {
    command -v openclaw &>/dev/null || return 0

    # Backup auth-profiles.json before restart (gateway might reset it)
    local BACKUP=""
    if [ -f "$PROFILES_FILE" ]; then
        BACKUP="$(cat "$PROFILES_FILE" 2>/dev/null)"
        echo "full_gateway_restart: backed up auth-profiles.json ($(wc -c < "$PROFILES_FILE") bytes)" >&2
    fi

    echo "full_gateway_restart: stopping gateway..." >&2
    openclaw gateway stop 2>/dev/null || true
    local GATEWAY_PORT="${OPENCLAW_GATEWAY_PORT:-18789}"
    local i
    for i in $(seq 1 15); do
        (lsof -nP -iTCP:"$GATEWAY_PORT" -sTCP:LISTEN 2>/dev/null | grep -q .) || break
        sleep 1
    done

    # Restore auth-profiles.json if gateway deleted it
    if [ -n "$BACKUP" ] && [ ! -f "$PROFILES_FILE" ]; then
        echo "full_gateway_restart: auth-profiles.json was DELETED by gateway stop, restoring..." >&2
        mkdir -p "$(dirname "$PROFILES_FILE")"
        echo "$BACKUP" > "$PROFILES_FILE"
        chmod 600 "$PROFILES_FILE" 2>/dev/null || true
    fi

    echo "full_gateway_restart: starting gateway..." >&2
    openclaw gateway start 2>/dev/null || true
    openclaw gateway health --timeout 20000 2>/dev/null || true

    # Verify auth-profiles.json still exists after start
    if [ -n "$BACKUP" ] && [ ! -f "$PROFILES_FILE" ]; then
        echo "full_gateway_restart: auth-profiles.json was DELETED by gateway start, restoring..." >&2
        mkdir -p "$(dirname "$PROFILES_FILE")"
        echo "$BACKUP" > "$PROFILES_FILE"
        chmod 600 "$PROFILES_FILE" 2>/dev/null || true
    fi

    if [ -f "$PROFILES_FILE" ]; then
        echo "full_gateway_restart: done (auth-profiles.json: $(wc -c < "$PROFILES_FILE") bytes)" >&2
    else
        echo "full_gateway_restart: done (WARNING: no auth-profiles.json at $PROFILES_FILE)" >&2
    fi
}

# true if this provider is handled via direct API (not CLI)
is_self_handled_provider() {
    case "$1" in
        qwen_portal|github_copilot|minimax_portal) return 0 ;; # device-code
        openai_codex|google_gemini_cli) return 0 ;; # redirect (direct)
        *) return 1 ;;
    esac
}

# ──────────────────────────────────────────────────────────────────────────────
# Provider: Qwen Portal (device-code with PKCE)
# ──────────────────────────────────────────────────────────────────────────────

QWEN_CLIENT_ID="f0304373b74a44d2b584a3fb70ca9e56"
QWEN_DEVICE_CODE_URL="https://chat.qwen.ai/api/v1/oauth2/device/code"
QWEN_TOKEN_URL="https://chat.qwen.ai/api/v1/oauth2/token"

qwen_request_device_code() {
    local challenge="$1"
    curl -s -w "\n%{http_code}" -X POST "$QWEN_DEVICE_CODE_URL" \
        -H "Content-Type: application/x-www-form-urlencoded" -H "Accept: application/json" \
        -d "client_id=${QWEN_CLIENT_ID}&scope=openid+profile+email+model.completion&code_challenge=${challenge}&code_challenge_method=S256"
}

qwen_poll_token() {
    local device_code="$1" verifier="$2"
    curl -s -w "\n%{http_code}" -X POST "$QWEN_TOKEN_URL" \
        -H "Content-Type: application/x-www-form-urlencoded" -H "Accept: application/json" \
        -d "grant_type=urn:ietf:params:oauth:grant-type:device_code&client_id=${QWEN_CLIENT_ID}&device_code=${device_code}&code_verifier=${verifier}"
}

save_qwen_token() {
    local access="$1" refresh="$2" expires="$3" resource_url="$4"
    save_auth_profile "qwen-portal:default" \
        "$(jq -n --arg a "$access" --arg r "$refresh" --argjson e "$expires" \
        '{ type: "oauth", provider: "qwen-portal", access: $a, refresh: $r, expires: $e }')" \
        || { echo "qwen_portal: failed to save profile" >&2; return 1; }
    OAUTH_TOKEN_SAVED=1
    echo "qwen_portal: saved OAuth token to $PROFILES_FILE" >&2

    local base_url="https://portal.qwen.ai/v1"
    if [ -n "$resource_url" ] && [ "$resource_url" != "null" ]; then
        base_url="$(echo "$resource_url" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's|/*$||')"
        echo "$base_url" | grep -qE '^https?://' || base_url="https://${base_url}"
        echo "$base_url" | grep -q '/v1$' || base_url="${base_url}/v1"
    fi
    echo "qwen_portal: using baseUrl=$base_url" >&2

    local cfg
    cfg="$(jq -n --arg bu "$base_url" '{
        auth: {
            profiles: { "qwen-portal:default": { provider: "qwen-portal", mode: "oauth" } },
            order: { "qwen-portal": ["qwen-portal:default"] }
        },
        models: { providers: { "qwen-portal": {
            baseUrl: $bu,
            apiKey: "qwen-oauth",
            api: "openai-completions",
            models: [
                { id: "coder-model", name: "Qwen Coder", reasoning: false, input: ["text"],
                  cost: { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 }, contextWindow: 128000, maxTokens: 8192 },
                { id: "vision-model", name: "Qwen Vision", reasoning: false, input: ["text","image"],
                  cost: { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 }, contextWindow: 128000, maxTokens: 8192 }
            ]
        }}},
        agents: { defaults: {
            model: { primary: "qwen-portal/coder-model" },
            models: {
                "qwen-portal/coder-model": { alias: "qwen" },
                "qwen-portal/vision-model": {}
            }
        }}
    }' 2>/dev/null)" || true
    if [ -n "$cfg" ]; then
        if apply_provider_config_patch "$cfg"; then
            echo "qwen_portal: config.patch applied" >&2
        else
            echo "qwen_portal: config.patch failed, saving for retry" >&2
            save_pending_config "qwen_portal" "$cfg"
        fi
    fi
    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Provider: GitHub Copilot (device-code, no PKCE)
# ──────────────────────────────────────────────────────────────────────────────

GH_CLIENT_ID="Iv1.b507a08c87ecfe98"
GH_DEVICE_CODE_URL="https://github.com/login/device/code"
GH_TOKEN_URL="https://github.com/login/oauth/access_token"

gh_request_device_code() {
    curl -s -w "\n%{http_code}" -X POST "$GH_DEVICE_CODE_URL" \
        -H "Content-Type: application/x-www-form-urlencoded" -H "Accept: application/json" \
        -d "client_id=${GH_CLIENT_ID}&scope=read:user"
}

gh_poll_token() {
    local device_code="$1"
    curl -s -w "\n%{http_code}" -X POST "$GH_TOKEN_URL" \
        -H "Content-Type: application/x-www-form-urlencoded" -H "Accept: application/json" \
        -d "client_id=${GH_CLIENT_ID}&device_code=${device_code}&grant_type=urn:ietf:params:oauth:grant-type:device_code"
}

save_github_copilot_token() {
    local token="$1"
    save_auth_profile "github-copilot:default" \
        "$(jq -n --arg t "$token" '{ type: "api_key", provider: "github-copilot", key: $t }')" \
        || { echo "github_copilot: failed to save profile" >&2; return 1; }
    OAUTH_TOKEN_SAVED=1
    echo "github_copilot: saved GitHub token to $PROFILES_FILE" >&2

    local cfg
    cfg="$(jq -n '{
        auth: {
            profiles: {
                "github-copilot:default": { provider: "github-copilot", mode: "api_key" }
            },
            order: { "github-copilot": ["github-copilot:default"] }
        },
        agents: { defaults: {
            model: { primary: "github-copilot/claude-opus-4-5" },
            models: {
                "github-copilot/claude-opus-4-5": { alias: "copilot" }
            }
        }}
    }' 2>/dev/null)" || true
    if [ -n "$cfg" ]; then
        if apply_provider_config_patch "$cfg"; then
            echo "github_copilot: config.patch applied" >&2
        else
            echo "github_copilot: config.patch failed, saving for retry" >&2
            save_pending_config "github_copilot" "$cfg"
        fi
    fi
    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Provider: MiniMax Portal (device-code with PKCE + state)
# ──────────────────────────────────────────────────────────────────────────────

MM_CLIENT_ID="78257093-7e40-4613-99e0-527b14b39113"
MM_CODE_URL="https://api.minimax.io/oauth/code"
MM_TOKEN_URL="https://api.minimax.io/oauth/token"

mm_request_device_code() {
    local challenge="$1" state="$2"
    curl -s -w "\n%{http_code}" -X POST "$MM_CODE_URL" \
        -H "Content-Type: application/x-www-form-urlencoded" -H "Accept: application/json" \
        -H "x-request-id: $(openssl rand -hex 16)" \
        -d "response_type=code&client_id=${MM_CLIENT_ID}&scope=group_id+profile+model.completion&code_challenge=${challenge}&code_challenge_method=S256&state=${state}"
}

mm_poll_token() {
    local user_code="$1" verifier="$2"
    curl -s -w "\n%{http_code}" -X POST "$MM_TOKEN_URL" \
        -H "Content-Type: application/x-www-form-urlencoded" -H "Accept: application/json" \
        -d "grant_type=urn:ietf:params:oauth:grant-type:user_code&client_id=${MM_CLIENT_ID}&user_code=${user_code}&code_verifier=${verifier}"
}

save_minimax_token() {
    local access="$1" refresh="$2" expires="$3" resource_url="$4"
    save_auth_profile "minimax-portal:default" \
        "$(jq -n --arg a "$access" --arg r "$refresh" --argjson e "$expires" \
        '{ type: "oauth", provider: "minimax-portal", access: $a, refresh: $r, expires: $e }')" \
        || { echo "minimax_portal: failed to save profile" >&2; return 1; }
    OAUTH_TOKEN_SAVED=1
    echo "minimax_portal: saved OAuth token to $PROFILES_FILE" >&2

    local base_url="https://api.minimax.io/anthropic"
    if [ -n "$resource_url" ] && [ "$resource_url" != "null" ]; then
        base_url="$(echo "$resource_url" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's|/*$||')"
        echo "$base_url" | grep -qE '^https?://' || base_url="https://${base_url}"
    fi
    echo "minimax_portal: using baseUrl=$base_url" >&2
    local cfg
    cfg="$(jq -n --arg bu "$base_url" '{
        auth: {
            profiles: {
                "minimax-portal:default": { provider: "minimax-portal", mode: "oauth" }
            },
            order: { "minimax-portal": ["minimax-portal:default"] }
        },
        models: { providers: { "minimax-portal": {
            baseUrl: $bu, apiKey: "minimax-oauth", api: "anthropic-messages",
            models: [
                { id: "MiniMax-M2.1", name: "MiniMax M2.1", reasoning: false, input: ["text"],
                  cost: { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 }, contextWindow: 200000, maxTokens: 8192 },
                { id: "MiniMax-M2.5", name: "MiniMax M2.5", reasoning: true, input: ["text"],
                  cost: { input: 0, output: 0, cacheRead: 0, cacheWrite: 0 }, contextWindow: 200000, maxTokens: 8192 }
            ]
        }}},
        agents: { defaults: {
            model: { primary: "minimax-portal/MiniMax-M2.1" },
            models: {
                "minimax-portal/MiniMax-M2.1": { alias: "minimax" },
                "minimax-portal/MiniMax-M2.5": {}
            }
        }}
    }' 2>/dev/null)" || true
    if [ -n "$cfg" ]; then
        if apply_provider_config_patch "$cfg"; then
            echo "minimax_portal: config.patch applied" >&2
        else
            echo "minimax_portal: config.patch failed, saving for retry" >&2
            save_pending_config "minimax_portal" "$cfg"
        fi
    fi
    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Provider: OpenAI Codex (redirect OAuth with PKCE)
# Source: @mariozechner/pi-ai → packages/ai/src/utils/oauth/openai-codex.ts
# ──────────────────────────────────────────────────────────────────────────────

OAI_CLIENT_ID="app_EMoamEEZ73f0CkXaXp7hrann"
OAI_AUTH_URL="https://auth.openai.com/oauth/authorize"
OAI_TOKEN_URL="https://auth.openai.com/oauth/token"
OAI_REDIRECT_URI="http://localhost:1455/auth/callback"
OAI_SCOPES="openid+profile+email+offline_access"

oai_build_auth_url() {
    local challenge="$1" state="$2"
    echo "${OAI_AUTH_URL}?client_id=${OAI_CLIENT_ID}&response_type=code&redirect_uri=$(printf '%s' "$OAI_REDIRECT_URI" | jq -sRr @uri)&scope=${OAI_SCOPES}&code_challenge=${challenge}&code_challenge_method=S256&state=${state}&id_token_add_organizations=true&codex_cli_simplified_flow=true&originator=pi"
}

oai_exchange_code() {
    local code="$1" verifier="$2"
    curl -s -w "\n%{http_code}" -X POST "$OAI_TOKEN_URL" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "grant_type=authorization_code&client_id=${OAI_CLIENT_ID}&code=${code}&code_verifier=${verifier}&redirect_uri=${OAI_REDIRECT_URI}"
}

save_openai_codex_token() {
    local access="$1" refresh="$2" expires="$3"
    save_auth_profile "openai-codex:default" \
        "$(jq -n --arg a "$access" --arg r "$refresh" --argjson e "$expires" \
        '{ type: "oauth", provider: "openai-codex", access: $a, refresh: $r, expires: $e }')" \
        || { echo "openai_codex: failed to save profile" >&2; return 1; }
    OAUTH_TOKEN_SAVED=1
    echo "openai_codex: saved OAuth token to $PROFILES_FILE" >&2

    local cfg
    cfg="$(jq -n '{
        auth: {
            profiles: {
                "openai-codex:default": { provider: "openai-codex", mode: "oauth" }
            },
            order: { "openai-codex": ["openai-codex:default"] }
        },
        agents: { defaults: {
            model: { primary: "openai-codex/gpt-5.3-codex" },
            models: {
                "openai-codex/gpt-5.3-codex": { alias: "codex" }
            }
        }}
    }' 2>/dev/null)" || true
    if [ -n "$cfg" ]; then
        if apply_provider_config_patch "$cfg"; then
            echo "openai_codex: config.patch applied" >&2
        else
            echo "openai_codex: config.patch failed, saving for retry" >&2
            save_pending_config "openai_codex" "$cfg"
        fi
    fi
    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Provider: Google Gemini CLI (redirect OAuth with PKCE)
# Source: extensions/google-gemini-cli-auth/oauth.ts
# ──────────────────────────────────────────────────────────────────────────────

GEMINI_AUTH_URL="https://accounts.google.com/o/oauth2/v2/auth"
GEMINI_TOKEN_URL="https://oauth2.googleapis.com/token"
GEMINI_REDIRECT_URI="http://localhost:8085/oauth2callback"
GEMINI_SCOPES="https://www.googleapis.com/auth/cloud-platform+https://www.googleapis.com/auth/userinfo.email+https://www.googleapis.com/auth/userinfo.profile"

extract_gemini_cli_credentials() {
    if [ -n "${OPENCLAW_GEMINI_OAUTH_CLIENT_ID:-}" ]; then
        echo "${OPENCLAW_GEMINI_OAUTH_CLIENT_ID} ${OPENCLAW_GEMINI_OAUTH_CLIENT_SECRET:-}"
        return 0
    fi
    if [ -n "${GEMINI_CLI_OAUTH_CLIENT_ID:-}" ]; then
        echo "${GEMINI_CLI_OAUTH_CLIENT_ID} ${GEMINI_CLI_OAUTH_CLIENT_SECRET:-}"
        return 0
    fi
    local gemini_path
    gemini_path="$(command -v gemini 2>/dev/null)" || return 1
    gemini_path="$(readlink -f "$gemini_path" 2>/dev/null || realpath "$gemini_path" 2>/dev/null)" || return 1
    local gemini_dir
    gemini_dir="$(dirname "$(dirname "$gemini_path")")"
    local search_paths=(
        "$gemini_dir/node_modules/@google/gemini-cli-core/dist/src/code_assist/oauth2.js"
        "$gemini_dir/node_modules/@google/gemini-cli-core/dist/code_assist/oauth2.js"
    )
    local content=""
    for p in "${search_paths[@]}"; do
        [ -f "$p" ] && { content="$(cat "$p" 2>/dev/null)"; break; }
    done
    [ -z "$content" ] && return 1
    local cid csecret
    cid="$(echo "$content" | grep -oE '[0-9]+-[a-z0-9]+\.apps\.googleusercontent\.com' | head -1)"
    csecret="$(echo "$content" | grep -oE 'GOCSPX-[A-Za-z0-9_-]+' | head -1)"
    [ -z "$cid" ] && return 1
    echo "$cid $csecret"
}

gemini_build_auth_url() {
    local client_id="$1" challenge="$2" state="$3"
    echo "${GEMINI_AUTH_URL}?client_id=${client_id}&response_type=code&redirect_uri=$(printf '%s' "$GEMINI_REDIRECT_URI" | jq -sRr @uri)&scope=${GEMINI_SCOPES}&code_challenge=${challenge}&code_challenge_method=S256&state=${state}&access_type=offline&prompt=consent"
}

gemini_exchange_code() {
    local client_id="$1" client_secret="$2" code="$3" verifier="$4"
    local body="client_id=${client_id}&code=${code}&grant_type=authorization_code&redirect_uri=${GEMINI_REDIRECT_URI}&code_verifier=${verifier}"
    [ -n "$client_secret" ] && body="${body}&client_secret=${client_secret}"
    curl -s -w "\n%{http_code}" -X POST "$GEMINI_TOKEN_URL" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "$body"
}

gemini_discover_project() {
    local access_token="$1"
    local env_project="${GOOGLE_CLOUD_PROJECT:-${GOOGLE_CLOUD_PROJECT_ID:-}}"
    [ -n "$env_project" ] && { echo "$env_project"; return 0; }
    local load_body
    load_body="$(jq -n '{ metadata: { ideType: "IDE_UNSPECIFIED", platform: "PLATFORM_UNSPECIFIED", pluginType: "GEMINI" } }')"
    local resp
    resp="$(curl -s -w "\n%{http_code}" -X POST "https://cloudcode-pa.googleapis.com/v1internal:loadCodeAssist" \
        -H "Authorization: Bearer $access_token" \
        -H "Content-Type: application/json" \
        -H "User-Agent: google-api-nodejs-client/9.15.1" \
        -d "$load_body")" || true
    local code="$(echo "$resp" | tail -1)"
    local body="$(echo "$resp" | sed '$d')"
    if [ "$code" = "200" ]; then
        local project
        project="$(echo "$body" | jq -r '.cloudaicompanionProject // .cloudaicompanionProject.id // empty' 2>/dev/null)"
        [ -n "$project" ] && { echo "$project"; return 0; }
    fi
    echo ""
}

save_gemini_cli_token() {
    local access="$1" refresh="$2" expires="$3" project_id="$4"
    local profile
    profile="$(jq -n --arg a "$access" --arg r "$refresh" --argjson e "$expires" --arg p "$project_id" \
        '{ type: "oauth", provider: "google-gemini-cli", access: $a, refresh: $r, expires: $e } + (if $p != "" then { projectId: $p } else {} end)')"
    save_auth_profile "google-gemini-cli:default" "$profile" \
        || { echo "google_gemini_cli: failed to save profile" >&2; return 1; }
    OAUTH_TOKEN_SAVED=1
    echo "google_gemini_cli: saved OAuth token to $PROFILES_FILE (project: ${project_id:-none})" >&2

    local cfg
    cfg="$(jq -n '{
        auth: {
            profiles: {
                "google-gemini-cli:default": { provider: "google-gemini-cli", mode: "oauth" }
            },
            order: { "google-gemini-cli": ["google-gemini-cli:default"] }
        },
        agents: { defaults: {
            model: { primary: "google-gemini-cli/gemini-3-pro-preview" },
            models: {
                "google-gemini-cli/gemini-3-pro-preview": { alias: "gemini" },
                "google-gemini-cli/gemini-3-flash-preview": {}
            }
        }}
    }' 2>/dev/null)" || true
    if [ -n "$cfg" ]; then
        if apply_provider_config_patch "$cfg"; then
            echo "google_gemini_cli: config.patch applied" >&2
        else
            echo "google_gemini_cli: config.patch failed, saving for retry" >&2
            save_pending_config "google_gemini_cli" "$cfg"
        fi
    fi
    return 0
}

# ──────────────────────────────────────────────────────────────────────────────
# Gateway init: allowInsecureAuth + enable bundled auth plugins (once)
# ──────────────────────────────────────────────────────────────────────────────

GATEWAY_INIT_FLAG="/tmp/openclaw-sync-gateway-init-done"
if command -v openclaw &>/dev/null; then
    if [ ! -f "$GATEWAY_INIT_FLAG" ]; then
        echo "gateway_init: first run — configuring plugins and settings" >&2
        openclaw config set gateway.controlUi.allowInsecureAuth true 2>/dev/null || true
        for _plugin in qwen-portal-auth copilot-proxy google-gemini-cli-auth minimax-portal-auth; do
            openclaw plugins enable "$_plugin" 2>/dev/null || true
        done
        openclaw gateway stop 2>/dev/null || true
        sleep 3
        openclaw gateway start 2>/dev/null || true
        touch "$GATEWAY_INIT_FLAG"
        echo "gateway_init: plugins enabled, gateway restarted" >&2
    fi
    openclaw gateway health --timeout 15000 2>/dev/null || true
fi

# ──────────────────────────────────────────────────────────────────────────────
# Pre-Phase 0: Fix provider baseUrl missing https:// protocol
# ──────────────────────────────────────────────────────────────────────────────

fix_provider_base_urls() {
    command -v openclaw &>/dev/null || return 0
    local GET_RESP FIXES=""
    GET_RESP="$(gateway_call_json config.get --params '{}')" || return 0
    [ -z "$GET_RESP" ] && return 0
    local providers_json
    providers_json="$(echo "$GET_RESP" | jq -c '.config.models.providers // {}' 2>/dev/null)" || return 0
    [ "$providers_json" = "{}" ] || [ "$providers_json" = "null" ] && return 0

    while IFS='=' read -r prov burl; do
        [ -z "$prov" ] || [ -z "$burl" ] && continue
        if ! echo "$burl" | grep -qE '^https?://'; then
            local fixed="https://${burl}"
            echo "fix_base_urls: $prov baseUrl '$burl' → '$fixed'" >&2
            FIXES="$(echo "${FIXES:-{\}}" | jq --arg p "$prov" --arg u "$fixed" \
                '.models.providers[$p].baseUrl = $u' 2>/dev/null)" || continue
        fi
    done < <(echo "$providers_json" | jq -r 'to_entries[] | select(.value.baseUrl != null) | "\(.key)=\(.value.baseUrl)"' 2>/dev/null)

    if [ -n "$FIXES" ] && [ "$FIXES" != "{}" ]; then
        local HASH
        HASH="$(echo "$GET_RESP" | jq -r '.hash // empty' 2>/dev/null)"
        if [ -n "$HASH" ]; then
            local FIX_RAW FIX_PARAMS
            FIX_RAW="$(echo "$FIXES" | jq -c '.' 2>/dev/null)"
            FIX_PARAMS="$(jq -n --arg h "$HASH" --arg r "$FIX_RAW" '{ baseHash: $h, raw: $r }' 2>/dev/null)"
            if gateway_call_json config.patch --params "$FIX_PARAMS" >/dev/null 2>&1; then
                echo "fix_base_urls: patched successfully" >&2
            else
                echo "fix_base_urls: patch failed" >&2
            fi
        fi
    fi
}
fix_provider_base_urls

# ──────────────────────────────────────────────────────────────────────────────
# Phase 0: Retry pending config patches + poll pending device-code flows
# ──────────────────────────────────────────────────────────────────────────────

retry_pending_configs

if [ -d "$DEVICE_CODE_STATE_DIR" ]; then
    for state_file in "$DEVICE_CODE_STATE_DIR"/*.json; do
        [ -f "$state_file" ] || continue
        STATE_KEY="$(basename "$state_file" .json)"
        STATE="$(jq -c '.' "$state_file" 2>/dev/null)" || { rm -f "$state_file"; continue; }
        STATE_TYPE="$(echo "$STATE" | jq -r '.type // "device_code"' 2>/dev/null)"

        # Redirect-flow states: only clean up expired ones; token exchange is in Phase 3
        if [ "$STATE_TYPE" = "redirect" ]; then
            R_EXP="$(echo "$STATE" | jq -r '.expires_at // 0')"
            if [ "$(date +%s)" -ge "$R_EXP" ]; then
                echo "redirect_cleanup.$STATE_KEY: expired, removing stale state" >&2
                rm -f "$state_file"
            fi
            continue
        fi

        DC="$(echo "$STATE" | jq -r '.device_code // empty')"
        UC="$(echo "$STATE" | jq -r '.user_code // empty')"
        VER="$(echo "$STATE" | jq -r '.verifier // empty')"
        EXP="$(echo "$STATE" | jq -r '.expires_at // 0')"
        NOW="$(date +%s)"

        if [ "$NOW" -ge "$EXP" ]; then
            echo "device_poll.$STATE_KEY: expired" >&2; rm -f "$state_file"; continue
        fi

        echo "device_poll.$STATE_KEY: polling ($(( EXP - NOW ))s left)" >&2

        POLL_RESP=""
        case "$STATE_KEY" in
            qwen_portal)
                [ -z "$DC" ] || [ -z "$VER" ] && { rm -f "$state_file"; continue; }
                POLL_RESP="$(qwen_poll_token "$DC" "$VER")" || true ;;
            github_copilot)
                [ -z "$DC" ] && { rm -f "$state_file"; continue; }
                POLL_RESP="$(gh_poll_token "$DC")" || true ;;
            minimax_portal)
                [ -z "$UC" ] || [ -z "$VER" ] && { rm -f "$state_file"; continue; }
                POLL_RESP="$(mm_poll_token "$UC" "$VER")" || true ;;
            *) echo "device_poll.$STATE_KEY: unknown provider" >&2; rm -f "$state_file"; continue ;;
        esac
        [ -z "$POLL_RESP" ] && continue
        POLL_CODE="$(echo "$POLL_RESP" | tail -1)"
        POLL_BODY="$(echo "$POLL_RESP" | sed '$d')"

        case "$STATE_KEY" in
            qwen_portal)
                if [ "$POLL_CODE" = "200" ]; then
                    ACCESS="$(echo "$POLL_BODY" | jq -r '.access_token // empty' 2>/dev/null)"
                    REFRESH="$(echo "$POLL_BODY" | jq -r '.refresh_token // empty' 2>/dev/null)"
                    EXPIRES_IN="$(echo "$POLL_BODY" | jq -r '.expires_in // 0' 2>/dev/null)"
                    RESOURCE_URL="$(echo "$POLL_BODY" | jq -r '.resource_url // empty' 2>/dev/null)"
                    if [ -n "$ACCESS" ] && [ -n "$REFRESH" ] && [ "$EXPIRES_IN" -gt 0 ] 2>/dev/null; then
                        echo "device_poll.qwen_portal: token received!" >&2
                        if save_qwen_token "$ACCESS" "$REFRESH" "$(( (NOW + EXPIRES_IN) * 1000 ))" "$RESOURCE_URL"; then
                            rm -f "$state_file"
                            post_oauth_consumed "$STATE_KEY"
                        fi
                    else echo "device_poll.qwen_portal: incomplete: $POLL_BODY" >&2; rm -f "$state_file"; fi
                else
                    PE="$(echo "$POLL_BODY" | jq -r '.error // empty' 2>/dev/null)"
                    case "$PE" in
                        authorization_pending) echo "device_poll.qwen_portal: pending" >&2 ;;
                        slow_down) echo "device_poll.qwen_portal: slow_down" >&2 ;;
                        expired_token|access_denied|invalid_grant) echo "device_poll.qwen_portal: $PE (removing state)" >&2; rm -f "$state_file" ;;
                        *) echo "device_poll.qwen_portal: ${PE:-HTTP $POLL_CODE}" >&2 ;;
                    esac
                fi ;;
            github_copilot)
                ACCESS="$(echo "$POLL_BODY" | jq -r '.access_token // empty' 2>/dev/null)"
                GH_ERR="$(echo "$POLL_BODY" | jq -r '.error // empty' 2>/dev/null)"
                if [ -n "$ACCESS" ] && [ -z "$GH_ERR" ]; then
                    echo "device_poll.github_copilot: token received!" >&2
                    if save_github_copilot_token "$ACCESS"; then
                        rm -f "$state_file"; post_oauth_consumed "$STATE_KEY"
                    fi
                else
                    case "$GH_ERR" in
                        authorization_pending) echo "device_poll.github_copilot: pending" >&2 ;;
                        slow_down) echo "device_poll.github_copilot: slow_down" >&2 ;;
                        expired_token|access_denied|invalid_grant) echo "device_poll.github_copilot: $GH_ERR (removing state)" >&2; rm -f "$state_file" ;;
                        *) echo "device_poll.github_copilot: ${GH_ERR:-HTTP $POLL_CODE}" >&2 ;;
                    esac
                fi ;;
            minimax_portal)
                MM_ST="$(echo "$POLL_BODY" | jq -r '.status // empty' 2>/dev/null)"
                if [ "$MM_ST" = "success" ]; then
                    ACCESS="$(echo "$POLL_BODY" | jq -r '.access_token // empty' 2>/dev/null)"
                    REFRESH="$(echo "$POLL_BODY" | jq -r '.refresh_token // empty' 2>/dev/null)"
                    MM_EXP="$(echo "$POLL_BODY" | jq -r '.expired_in // 0' 2>/dev/null)"
                    RURL="$(echo "$POLL_BODY" | jq -r '.resource_url // empty' 2>/dev/null)"
                    if [ -n "$ACCESS" ] && [ -n "$REFRESH" ] && [ "$MM_EXP" -gt 0 ] 2>/dev/null; then
                        echo "device_poll.minimax_portal: token received!" >&2
                        if save_minimax_token "$ACCESS" "$REFRESH" "$MM_EXP" "$RURL"; then
                            rm -f "$state_file"; post_oauth_consumed "$STATE_KEY"
                        fi
                    else echo "device_poll.minimax_portal: incomplete" >&2; rm -f "$state_file"; fi
                elif [ "$MM_ST" = "error" ]; then
                    echo "device_poll.minimax_portal: error" >&2; rm -f "$state_file"
                else echo "device_poll.minimax_portal: pending" >&2; fi ;;
        esac
    done
fi

# NOTE: don't restart here — defer to a single restart after Phase 3
# to avoid double-restart when tokens arrive in both Phase 0 and Phase 3.

# ──────────────────────────────────────────────────────────────────────────────
# 0) Fetch config from xNode
# ──────────────────────────────────────────────────────────────────────────────

RESP="$(curl -s -S -w "\n%{http_code}" -H "Authorization: Bearer $OPENCLAW_CONFIG_TOKEN" "$OPENCLAW_API_BASE/openclaw/config")"
HTTP_CODE="$(echo "$RESP" | tail -1)"
RESP_BODY="$(echo "$RESP" | sed '$d')"
if [ "$HTTP_CODE" != "200" ]; then echo "Failed to fetch config: HTTP $HTTP_CODE" >&2; exit 1; fi
if ! echo "$RESP_BODY" | jq -e . >/dev/null 2>&1; then echo "Config response is not valid JSON" >&2; exit 1; fi
RESP="$RESP_BODY"

# ──────────────────────────────────────────────────────────────────────────────
# 1) Write API keys to ~/.openclaw/.env + apply config via config.patch
# ──────────────────────────────────────────────────────────────────────────────

ENV_JSON="$(echo "$RESP" | jq -c '.env // empty' 2>/dev/null)" || ENV_JSON=""
AGENTS_DEFAULTS="$(echo "$RESP" | jq -c '.agents_defaults // empty' 2>/dev/null)" || AGENTS_DEFAULTS=""
TOOLS_WEB_SEARCH="$(echo "$RESP" | jq -c '.tools_web_search // empty' 2>/dev/null)" || TOOLS_WEB_SEARCH=""

# Write API keys to ~/.openclaw/.env (primary source for env vars)
if [ -n "$ENV_JSON" ] && [ "$ENV_JSON" != "null" ] && [ "$ENV_JSON" != "{}" ]; then
    OPENCLAW_ENV_FILE="$OPENCLAW_STATE_DIR/.env"
    mkdir -p "$OPENCLAW_STATE_DIR"

    EXISTING_ENV=""
    [ -f "$OPENCLAW_ENV_FILE" ] && EXISTING_ENV="$(cat "$OPENCLAW_ENV_FILE" 2>/dev/null)" || true

    NEW_ENV="$EXISTING_ENV"
    while IFS='=' read -r ekey eval; do
        [ -z "$ekey" ] && continue
        ESCAPED_VAL="$(printf '%s' "$eval" | sed "s/'/'\\\\''/g")"
        if echo "$NEW_ENV" | grep -q "^${ekey}="; then
            NEW_ENV="$(echo "$NEW_ENV" | sed "s|^${ekey}=.*|${ekey}='${ESCAPED_VAL}'|")"
        else
            [ -n "$NEW_ENV" ] && NEW_ENV="${NEW_ENV}"$'\n'"${ekey}='${ESCAPED_VAL}'" || NEW_ENV="${ekey}='${ESCAPED_VAL}'"
        fi
    done < <(echo "$ENV_JSON" | jq -r 'to_entries[] | select(.value != null and (.value | tostring | length) > 0) | "\(.key)=\(.value)"' 2>/dev/null)

    if [ "$NEW_ENV" != "$EXISTING_ENV" ]; then
        echo "$NEW_ENV" > "$OPENCLAW_ENV_FILE"
        echo "env: updated $OPENCLAW_ENV_FILE ($(echo "$ENV_JSON" | jq 'keys | length' 2>/dev/null) keys)" >&2
    fi
fi

# Build and apply config.patch (agents_defaults + tools_web_search + env)
NEED_PATCH="false"
if [ -n "$AGENTS_DEFAULTS" ] && [ "$AGENTS_DEFAULTS" != "null" ] && \
   [ "$(echo "$AGENTS_DEFAULTS" | jq -r 'keys | length' 2>/dev/null)" -gt 0 ] 2>/dev/null; then NEED_PATCH="true"; fi
if [ -n "$TOOLS_WEB_SEARCH" ] && [ "$TOOLS_WEB_SEARCH" != "null" ]; then NEED_PATCH="true"; fi
if [ -n "$ENV_JSON" ] && [ "$ENV_JSON" != "null" ] && [ "$ENV_JSON" != "{}" ]; then NEED_PATCH="true"; fi

if [ "$NEED_PATCH" = "true" ] && command -v openclaw &>/dev/null; then
    GET_RESP_MAIN="$(gateway_call_json config.get --params '{}')" || GET_RESP_MAIN=""
    HASH=""
    if [ -n "$GET_RESP_MAIN" ]; then
        HASH="$(echo "$GET_RESP_MAIN" | jq -r '.hash // empty' 2>/dev/null)" || HASH=""
        if [ -z "$HASH" ]; then
            _keys="$(echo "$GET_RESP_MAIN" | jq -r 'keys | join(", ")' 2>/dev/null)" || _keys="?"
            echo "Warning: config.get returned JSON but no hash field (keys: $_keys)" >&2
        fi
    else
        echo "Warning: config.get returned empty (gateway may be restarting)" >&2
    fi
    if [ -n "$HASH" ]; then
        RAW_JSON="$(jq -n \
            --argjson ad "${AGENTS_DEFAULTS:-null}" \
            --argjson tw "${TOOLS_WEB_SEARCH:-null}" \
            --argjson ev "${ENV_JSON:-null}" \
            '(if $ad != null and ($ad | type) == "object" and ($ad | keys | length) > 0
              then { agents: { defaults: $ad } } else {} end)
           * (if $tw != null and ($tw | type) == "object" and ($tw | keys | length) > 0
              then { tools: { web: { search: $tw } } } else {} end)
           * (if $ev != null and ($ev | type) == "object" and ($ev | keys | length) > 0
              then { env: $ev } else {} end)' \
            2>/dev/null | jq -c . 2>/dev/null)" || RAW_JSON=""
        if [ -n "$RAW_JSON" ] && [ "$RAW_JSON" != "{}" ]; then
            PARAMS="$(jq -n --arg h "$HASH" --arg r "$RAW_JSON" '{ baseHash: $h, raw: $r }' 2>/dev/null)" || true
            if [ -n "$PARAMS" ]; then
                PATCH_OUT="$(gateway_call_json config.patch --params "$PARAMS")" || echo "Warning: config.patch failed" >&2
            fi
        fi
    else
        echo "Warning: main config.patch skipped — could not get baseHash" >&2
    fi
fi

# ──────────────────────────────────────────────────────────────────────────────
# 2) oauth_url_requests: enable plugin → restart gateway → get auth URL → POST
# ──────────────────────────────────────────────────────────────────────────────

OAUTH_URL_REQUESTS_RAW="$(echo "$RESP" | jq -r '.oauth_url_requests // {} | to_entries[] | select(.value == true) | .key' 2>/dev/null)" || true
[ -z "$OAUTH_URL_REQUESTS_RAW" ] && OAUTH_URL_REQUESTS_RAW=""

# -- Phase A: enable plugins --
NEED_GATEWAY_RESTART=0
while IFS= read -r KEY || [ -n "$KEY" ]; do
    KEY="$(echo "${KEY:-}" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$KEY" ] && continue
    command -v openclaw &>/dev/null || continue
    PLUGIN="$(plugin_for_key "$KEY")"
    [ -z "$PLUGIN" ] && continue
    openclaw plugins list 2>/dev/null | grep -qi "$PLUGIN" && continue
    if ENABLE_OUT="$(openclaw plugins enable "$PLUGIN" 2>&1)"; then
        echo "plugins enable $PLUGIN: $ENABLE_OUT" >&2; NEED_GATEWAY_RESTART=1
    else
        echo "plugins enable $PLUGIN: failed - $ENABLE_OUT" >&2
    fi
done <<< "$OAUTH_URL_REQUESTS_RAW"

if [ "$NEED_GATEWAY_RESTART" = "1" ]; then
    SKIP_RESTART=0
    if [ -f "$RESTART_FLAG" ]; then
        FLAG_MTIME="$(stat -c %Y "$RESTART_FLAG" 2>/dev/null || stat -f %m "$RESTART_FLAG" 2>/dev/null || echo 0)"
        [ "$(( $(date +%s) - FLAG_MTIME ))" -lt 120 ] && SKIP_RESTART=1
    fi
    if [ "$SKIP_RESTART" = "0" ]; then
        echo "Restarting gateway for new plugin(s)..." >&2
        openclaw gateway stop 2>&1 || true
        GATEWAY_PORT="${OPENCLAW_GATEWAY_PORT:-18789}"
        for i in $(seq 1 10); do
            (lsof -nP -iTCP:"$GATEWAY_PORT" -sTCP:LISTEN 2>/dev/null | grep -q .) || break
            sleep 1
        done
        openclaw gateway start 2>&1 || true
        touch "$RESTART_FLAG"
        echo "Gateway restarted. URLs will be fetched next run." >&2
        exit 0
    fi
fi

# -- Pre-flight: gateway health for CLI-based providers --
GATEWAY_HEALTHY=""
needs_gateway_for_cli() {
    while IFS= read -r K || [ -n "$K" ]; do
        K="$(echo "${K:-}" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
        [ -z "$K" ] && continue
        is_self_handled_provider "$K" || return 0
    done <<< "$OAUTH_URL_REQUESTS_RAW"
    return 1
}
if [ -n "$OAUTH_URL_REQUESTS_RAW" ] && needs_gateway_for_cli; then
    if command -v openclaw &>/dev/null && ! openclaw gateway health --timeout 10000 2>/dev/null; then
        GATEWAY_HEALTHY="no"
        echo "Gateway unhealthy; CLI-based auth URLs will be skipped." >&2
    fi
fi

# -- Phase B: get auth URL per provider --

get_auth_url_via_cli() {
    local provider="$1" raw_out url
    if [ "$HAS_SCRIPT_PTY" = "1" ]; then
        local cmd; cmd="$(printf '%q ' openclaw models auth login --provider "$provider")"
        raw_out="$(timeout 45 script -q -e -c "$cmd" /dev/null 2>&1)" || true
    else
        raw_out="$(run_with_timeout 45 openclaw models auth login --provider "$provider")" || true
    fi
    url="$(printf '%s' "$raw_out" | LC_ALL=C tr -d '\000-\010\016-\037' | grep -oE 'https://[^ "'\''<>{}|\\^`\[\]]+' | head -1)"
    [ -z "$url" ] && echo "CLI produced no URL. Output: $(printf '%s' "$raw_out" | strip_ansi | head -c 500)" >&2
    echo "$url"
}

while IFS= read -r KEY || [ -n "$KEY" ]; do
    KEY="$(echo "${KEY:-}" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$KEY" ] && continue

    # If state file exists but user explicitly re-requested, clear stale state
    if [ -f "$DEVICE_CODE_STATE_DIR/$KEY.json" ]; then
        echo "oauth_url_requests.$KEY: re-requested, clearing previous state" >&2
        rm -f "$DEVICE_CODE_STATE_DIR/$KEY.json"
    fi

    AUTH_URL=""

    case "$KEY" in

        # ── Qwen: device-code ──
        qwen_portal)
            PKCE="$(generate_pkce)"; VERIFIER="${PKCE%% *}"; CHALLENGE="${PKCE##* }"
            DC_RESP="$(qwen_request_device_code "$CHALLENGE")" || true
            DC_CODE="$(echo "$DC_RESP" | tail -1)"; DC_BODY="$(echo "$DC_RESP" | sed '$d')"
            if [ "$DC_CODE" = "200" ]; then
                DEVICE_CODE="$(echo "$DC_BODY" | jq -r '.device_code // empty' 2>/dev/null)"
                USER_CODE="$(echo "$DC_BODY" | jq -r '.user_code // empty' 2>/dev/null)"
                VURI="$(echo "$DC_BODY" | jq -r '.verification_uri_complete // .verification_uri // empty' 2>/dev/null)"
                EXP_IN="$(echo "$DC_BODY" | jq -r '.expires_in // 600' 2>/dev/null)"
                INTV="$(echo "$DC_BODY" | jq -r '.interval // 2' 2>/dev/null)"
                AUTH_URL="$VURI"
                [ -n "$DEVICE_CODE" ] && [ -n "$AUTH_URL" ] && \
                    save_state "$KEY" --arg dc "$DEVICE_CODE" --arg uc "$USER_CODE" --arg v "$VERIFIER" \
                        --argjson ea "$(( $(date +%s) + EXP_IN ))" --argjson iv "$INTV" \
                        '{ device_code: $dc, user_code: $uc, verifier: $v, expires_at: $ea, interval: $iv }' && \
                    echo "oauth_url_requests.qwen_portal: URL ready (code: ${USER_CODE:-n/a})" >&2
            else echo "oauth_url_requests.qwen_portal: HTTP $DC_CODE" >&2; fi ;;

        # ── GitHub Copilot: device-code ──
        github_copilot)
            DC_RESP="$(gh_request_device_code)" || true
            DC_CODE="$(echo "$DC_RESP" | tail -1)"; DC_BODY="$(echo "$DC_RESP" | sed '$d')"
            if [ "$DC_CODE" = "200" ]; then
                DEVICE_CODE="$(echo "$DC_BODY" | jq -r '.device_code // empty' 2>/dev/null)"
                USER_CODE="$(echo "$DC_BODY" | jq -r '.user_code // empty' 2>/dev/null)"
                VURI="$(echo "$DC_BODY" | jq -r '.verification_uri // empty' 2>/dev/null)"
                EXP_IN="$(echo "$DC_BODY" | jq -r '.expires_in // 900' 2>/dev/null)"
                INTV="$(echo "$DC_BODY" | jq -r '.interval // 5' 2>/dev/null)"
                AUTH_URL="$VURI"
                [ -n "$DEVICE_CODE" ] && [ -n "$AUTH_URL" ] && \
                    save_state "$KEY" --arg dc "$DEVICE_CODE" --arg uc "$USER_CODE" --arg v "" \
                        --argjson ea "$(( $(date +%s) + EXP_IN ))" --argjson iv "$INTV" \
                        '{ device_code: $dc, user_code: $uc, verifier: $v, expires_at: $ea, interval: $iv }' && \
                    echo "oauth_url_requests.github_copilot: URL ready (code: ${USER_CODE:-n/a})" >&2
                [ -n "$USER_CODE" ] && AUTH_URL="${AUTH_URL}?user_code=${USER_CODE}"
            else echo "oauth_url_requests.github_copilot: HTTP $DC_CODE" >&2; fi ;;

        # ── MiniMax: device-code with PKCE + state ──
        minimax_portal)
            PKCE="$(generate_pkce)"; VERIFIER="${PKCE%% *}"; CHALLENGE="${PKCE##* }"
            MM_STATE="$(openssl rand -base64 16 | tr '+/' '-_' | tr -d '=')"
            DC_RESP="$(mm_request_device_code "$CHALLENGE" "$MM_STATE")" || true
            DC_CODE="$(echo "$DC_RESP" | tail -1)"; DC_BODY="$(echo "$DC_RESP" | sed '$d')"
            if [ "$DC_CODE" = "200" ]; then
                USER_CODE="$(echo "$DC_BODY" | jq -r '.user_code // empty' 2>/dev/null)"
                VURI="$(echo "$DC_BODY" | jq -r '.verification_uri // empty' 2>/dev/null)"
                MM_EXP_IN="$(echo "$DC_BODY" | jq -r '.expired_in // 0' 2>/dev/null)"
                INTV="$(echo "$DC_BODY" | jq -r '.interval // 2000' 2>/dev/null)"
                RESP_STATE="$(echo "$DC_BODY" | jq -r '.state // empty' 2>/dev/null)"
                if [ "$RESP_STATE" != "$MM_STATE" ]; then
                    echo "oauth_url_requests.minimax_portal: state mismatch" >&2
                elif [ -n "$USER_CODE" ] && [ -n "$VURI" ]; then
                    AUTH_URL="$VURI"
                    NOW_MS="$(( $(date +%s) * 1000 ))"
                    if [ "$MM_EXP_IN" -gt "$NOW_MS" ] 2>/dev/null; then EXP_S="$(( MM_EXP_IN / 1000 ))"
                    else EXP_S="$(( $(date +%s) + 600 ))"; fi
                    INTV_S="$(( INTV / 1000 ))"; [ "$INTV_S" -lt 2 ] && INTV_S=2
                    save_state "$KEY" --arg dc "" --arg uc "$USER_CODE" --arg v "$VERIFIER" \
                        --argjson ea "$EXP_S" --argjson iv "$INTV_S" \
                        '{ device_code: $dc, user_code: $uc, verifier: $v, expires_at: $ea, interval: $iv }'
                    echo "oauth_url_requests.minimax_portal: URL ready (code: $USER_CODE)" >&2
                fi
            else echo "oauth_url_requests.minimax_portal: HTTP $DC_CODE" >&2; fi ;;

        # ── OpenAI Codex: redirect OAuth with PKCE ──
        openai_codex)
            PKCE="$(generate_pkce)"; VERIFIER="${PKCE%% *}"; CHALLENGE="${PKCE##* }"
            OAI_STATE="$(openssl rand -hex 16)"
            AUTH_URL="$(oai_build_auth_url "$CHALLENGE" "$OAI_STATE")"
            save_state "$KEY" --arg v "$VERIFIER" --arg s "$OAI_STATE" --argjson ea "$(( $(date +%s) + 600 ))" \
                '{ type: "redirect", verifier: $v, state: $s, expires_at: $ea }'
            echo "oauth_url_requests.openai_codex: redirect URL ready" >&2
            ;;

        # ── Google Gemini CLI: redirect OAuth with PKCE ──
        google_gemini_cli)
            GCREDS="$(extract_gemini_cli_credentials 2>/dev/null)" || GCREDS=""
            if [ -z "$GCREDS" ]; then
                echo "oauth_url_requests.google_gemini_cli: no client_id (install gemini-cli or set GEMINI_CLI_OAUTH_CLIENT_ID)" >&2
                continue
            fi
            G_CID="${GCREDS%% *}"; G_CSECRET="${GCREDS#* }"
            [ "$G_CSECRET" = "$G_CID" ] && G_CSECRET=""
            PKCE="$(generate_pkce)"; VERIFIER="${PKCE%% *}"; CHALLENGE="${PKCE##* }"
            G_STATE="$(openssl rand -hex 16)"
            AUTH_URL="$(gemini_build_auth_url "$G_CID" "$CHALLENGE" "$G_STATE")"
            save_state "$KEY" --arg v "$VERIFIER" --arg s "$G_STATE" --arg cid "$G_CID" --arg cs "$G_CSECRET" \
                --argjson ea "$(( $(date +%s) + 600 ))" \
                '{ type: "redirect", verifier: $v, state: $s, client_id: $cid, client_secret: $cs, expires_at: $ea }'
            echo "oauth_url_requests.google_gemini_cli: redirect URL ready" >&2
            ;;

        # ── All other providers: CLI fallback ──
        *)
            command -v openclaw &>/dev/null || { echo "oauth_url_requests.$KEY: openclaw not in PATH" >&2; continue; }
            [ "$GATEWAY_HEALTHY" = "no" ] && { echo "oauth_url_requests.$KEY: skipped (gateway unhealthy)" >&2; continue; }
            PROVIDER="$(provider_for_key "$KEY")"
            AUTH_URL="$(get_auth_url_via_cli "$PROVIDER")"
            [ -n "$AUTH_URL" ] && echo "oauth_url_requests.$KEY: URL from CLI" >&2
            ;;
    esac

    if [ -z "$AUTH_URL" ]; then echo "oauth_url_requests.$KEY: no URL obtained" >&2; continue; fi

    POST_BODY="$(jq -n --arg k "$KEY" --arg u "$AUTH_URL" '{ key: $k, auth_url: $u }')" || continue
    POST_RESP="$(curl -s -w "\n%{http_code}" -X POST \
        -H "Authorization: Bearer $OPENCLAW_CONFIG_TOKEN" \
        -H "Content-Type: application/json" \
        -d "$POST_BODY" "$OPENCLAW_API_BASE/openclaw/oauth-auth-url")" || true
    POST_CODE="$(echo "$POST_RESP" | tail -1)"
    if [ "$POST_CODE" = "200" ] && echo "$POST_RESP" | sed '$d' | jq -e '.ok' >/dev/null 2>&1; then
        echo "oauth_url_requests.$KEY: sent to xNode" >&2; rm -f "$RESTART_FLAG"
    else echo "oauth_url_requests.$KEY: POST failed (HTTP $POST_CODE)" >&2; fi
done <<< "$OAUTH_URL_REQUESTS_RAW"

# ──────────────────────────────────────────────────────────────────────────────
# 3) oauth_pending: apply tokens/URLs, then mark consumed
# ──────────────────────────────────────────────────────────────────────────────

OAUTH_PENDING_KEYS="$(echo "$RESP" | jq -r '.oauth_pending // {} | keys[]' 2>/dev/null)" || true
if [ -z "$OAUTH_PENDING_KEYS" ]; then
    if [ "$OAUTH_TOKEN_SAVED" = "1" ]; then
        full_gateway_restart
        OAUTH_TOKEN_SAVED=0
    fi
    exit 0
fi

CONSUMED=()
while IFS= read -r KEY || [ -n "$KEY" ]; do
    KEY="$(echo "${KEY:-}" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$KEY" ] && continue

    VAL="$(echo "$RESP" | jq -r --arg k "$KEY" '.oauth_pending[$k] // empty' 2>/dev/null)" || VAL=""

    case "$KEY" in

        # Device-code providers: token is via Phase 0 polling, not the pasted value
        qwen_portal|github_copilot|minimax_portal)
            echo "oauth_pending.$KEY: consumed (device-code handled by polling)" >&2
            CONSUMED+=("$KEY")
            ;;

        # ── OpenAI Codex: exchange authorization code using saved PKCE verifier ──
        openai_codex)
            [ -z "$VAL" ] || [ "$VAL" = "null" ] && continue
            SF="$DEVICE_CODE_STATE_DIR/$KEY.json"
            if [ ! -f "$SF" ]; then
                echo "oauth_pending.openai_codex: no saved state (verifier missing); re-request auth link" >&2; continue
            fi
            S="$(jq -c '.' "$SF" 2>/dev/null)" || continue
            VERIFIER="$(echo "$S" | jq -r '.verifier // empty')"
            SAVED_STATE="$(echo "$S" | jq -r '.state // empty')"
            [ -z "$VERIFIER" ] && { echo "oauth_pending.openai_codex: no verifier" >&2; rm -f "$SF"; continue; }

            CODE="$(extract_url_param "$VAL" "code")"
            [ -z "$CODE" ] && { echo "oauth_pending.openai_codex: no 'code' in pasted URL: $VAL" >&2; continue; }

            URL_STATE="$(extract_url_param "$VAL" "state")"
            if [ -n "$SAVED_STATE" ] && [ -n "$URL_STATE" ] && [ "$SAVED_STATE" != "$URL_STATE" ]; then
                echo "oauth_pending.openai_codex: state mismatch" >&2; continue
            fi

            echo "oauth_pending.openai_codex: exchanging code..." >&2
            T_RESP="$(oai_exchange_code "$CODE" "$VERIFIER")" || true
            T_CODE="$(echo "$T_RESP" | tail -1)"; T_BODY="$(echo "$T_RESP" | sed '$d')"

            if [ "$T_CODE" = "200" ]; then
                ACCESS="$(echo "$T_BODY" | jq -r '.access_token // empty' 2>/dev/null)"
                REFRESH="$(echo "$T_BODY" | jq -r '.refresh_token // empty' 2>/dev/null)"
                EXP_IN="$(echo "$T_BODY" | jq -r '.expires_in // 3600' 2>/dev/null)"
                if [ -n "$ACCESS" ]; then
                    EXP_MS="$(( ($(date +%s) + EXP_IN) * 1000 ))"
                    if save_openai_codex_token "$ACCESS" "$REFRESH" "$EXP_MS"; then
                        rm -f "$SF"; CONSUMED+=("$KEY")
                        echo "oauth_pending.openai_codex: success!" >&2
                    fi
                else echo "oauth_pending.openai_codex: no access_token: $T_BODY" >&2; fi
            else echo "oauth_pending.openai_codex: exchange failed HTTP $T_CODE: $T_BODY" >&2; fi
            ;;

        # ── Google Gemini CLI: exchange code using saved PKCE verifier + client_id ──
        google_gemini_cli)
            [ -z "$VAL" ] || [ "$VAL" = "null" ] && continue
            SF="$DEVICE_CODE_STATE_DIR/$KEY.json"
            if [ ! -f "$SF" ]; then
                echo "oauth_pending.google_gemini_cli: no saved state; re-request auth link" >&2; continue
            fi
            S="$(jq -c '.' "$SF" 2>/dev/null)" || continue
            VERIFIER="$(echo "$S" | jq -r '.verifier // empty')"
            SAVED_STATE="$(echo "$S" | jq -r '.state // empty')"
            G_CID="$(echo "$S" | jq -r '.client_id // empty')"
            G_CSECRET="$(echo "$S" | jq -r '.client_secret // empty')"
            [ -z "$VERIFIER" ] || [ -z "$G_CID" ] && { echo "oauth_pending.google_gemini_cli: incomplete state" >&2; rm -f "$SF"; continue; }

            CODE="$(extract_url_param "$VAL" "code")"
            [ -z "$CODE" ] && { echo "oauth_pending.google_gemini_cli: no 'code' in pasted URL" >&2; continue; }

            URL_STATE="$(extract_url_param "$VAL" "state")"
            if [ -n "$SAVED_STATE" ] && [ -n "$URL_STATE" ] && [ "$SAVED_STATE" != "$URL_STATE" ]; then
                echo "oauth_pending.google_gemini_cli: state mismatch" >&2; continue
            fi

            echo "oauth_pending.google_gemini_cli: exchanging code..." >&2
            T_RESP="$(gemini_exchange_code "$G_CID" "$G_CSECRET" "$CODE" "$VERIFIER")" || true
            T_CODE="$(echo "$T_RESP" | tail -1)"; T_BODY="$(echo "$T_RESP" | sed '$d')"

            if [ "$T_CODE" = "200" ]; then
                ACCESS="$(echo "$T_BODY" | jq -r '.access_token // empty' 2>/dev/null)"
                REFRESH="$(echo "$T_BODY" | jq -r '.refresh_token // empty' 2>/dev/null)"
                EXP_IN="$(echo "$T_BODY" | jq -r '.expires_in // 3600' 2>/dev/null)"
                if [ -n "$ACCESS" ] && [ -n "$REFRESH" ]; then
                    EXP_MS="$(( ($(date +%s) + EXP_IN) * 1000 ))"
                    PROJECT="$(gemini_discover_project "$ACCESS")" || PROJECT=""
                    if save_gemini_cli_token "$ACCESS" "$REFRESH" "$EXP_MS" "$PROJECT"; then
                        rm -f "$SF"; CONSUMED+=("$KEY")
                        echo "oauth_pending.google_gemini_cli: success!" >&2
                    fi
                else echo "oauth_pending.google_gemini_cli: no tokens: $T_BODY" >&2; fi
            else echo "oauth_pending.google_gemini_cli: exchange failed HTTP $T_CODE: $T_BODY" >&2; fi
            ;;

        # ── Anthropic: paste-token ──
        anthropic_setup_token)
            [ -z "$VAL" ] || [ "$VAL" = "null" ] && continue
            if echo "$VAL" | openclaw models auth paste-token --provider anthropic 2>/dev/null; then
                CONSUMED+=("$KEY")
            fi
            ;;

        # ── CLI fallback for everything else ──
        *)
            [ -z "$VAL" ] || [ "$VAL" = "null" ] && continue
            echo "oauth_pending.$KEY: WARNING - CLI fallback may not work for redirect OAuth (PKCE mismatch)" >&2
            PROVIDER="$(echo "$KEY" | sed 's/_/-/g')"
            if (echo "$VAL"; sleep 1) | run_with_timeout 45 openclaw models auth login --provider "$PROVIDER" 2>/dev/null; then
                CONSUMED+=("$KEY")
            fi
            ;;
    esac
done <<< "$OAUTH_PENDING_KEYS"

# Single full restart if any OAuth tokens were saved (Phase 0 or Phase 3)
if [ "$OAUTH_TOKEN_SAVED" = "1" ]; then
    full_gateway_restart
    OAUTH_TOKEN_SAVED=0
fi

[ ${#CONSUMED[@]} -eq 0 ] && exit 0

KEYS_JSON="$(printf '%s\n' "${CONSUMED[@]}" | jq -R . | jq -s . 2>/dev/null)" || exit 1
CONSUMED_RESP="$(curl -s -w "\n%{http_code}" -X POST \
    -H "Authorization: Bearer $OPENCLAW_CONFIG_TOKEN" \
    -H "Content-Type: application/json" \
    -d "{\"keys\": $KEYS_JSON}" \
    "$OPENCLAW_API_BASE/openclaw/oauth-consumed")" || true
CONSUMED_CODE="$(echo "$CONSUMED_RESP" | tail -1)"
if [ "$CONSUMED_CODE" != "200" ]; then
    echo "Warning: POST oauth-consumed HTTP $CONSUMED_CODE" >&2
fi

exit 0
